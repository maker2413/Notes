#+TITLE: Java Gradle Project
#+PROPERTY: header-args

This is just a super simple java project to show some of the basics of gradle. This project was generated by running
~gradle init~ followed by selecting =application=, =Java=, =Groovy=, =JUnit 4= for a test framework, the default project,
name, and a source package name (com.maker2413.gradle in this case).

When we select =application= for a project type gradle will create a =app= directory with the apporpriate folder structure
for the project language selected. Let's run ~tree~ to see the directory structure of a Java project after running
~gradle init~ with the above inputs:
#+BEGIN_SRC sh :results output :noweb yes
tree .
#+END_SRC
*Outputs*:
#+begin_example
.
├── app
│   ├── build.gradle
│   └── src
│       ├── main
│       │   ├── java
│       │   │   └── com
│       │   │       └── maker2413
│       │   │           └── gradle
│       │   │               └── App.java
│       │   └── resources
│       └── test
│           ├── java
│           │   └── com
│           │       └── maker2413
│           │           └── gradle
│           │               └── AppTest.java
│           └── resources
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradlew
├── gradlew.bat
├── README.org
└── settings.gradle

16 directories, 9 files
#+end_example

You will notice that this time we have the =app= directory mentioned above and it contains both our source code and our
test code which in this case will be =JUnit 4= format. You will also notice that if we ~cat~ our =App.java= it even
created a simple beginning Java Application for us:
#+BEGIN_SRC sh :results output :noweb yes
cat app/src/main/java/com/maker2413/gradle/App.java
#+END_SRC
*Outputs*:
#+begin_example
/*
 ,* This Java source file was generated by the Gradle 'init' task.
 ,*/
package com.maker2413.gradle;

public class App {
    public String getGreeting() {
        return "Hello World!";
    }

    public static void main(String[] args) {
        System.out.println(new App().getGreeting());
    }
}
#+end_example

It also generated a simple test for our java application:
#+BEGIN_SRC sh :results output :noweb yes
cat app/src/test/java/com/maker2413/gradle/AppTest.java
#+END_SRC
*Outputs*:
#+begin_example
/*
 ,* This Java source file was generated by the Gradle 'init' task.
 ,*/
package com.maker2413.gradle;

import org.junit.Test;
import static org.junit.Assert.*;

public class AppTest {
    @Test public void testAppHasAGreeting() {
        App classUnderTest = new App();
        assertNotNull("app should have a greeting", classUnderTest.getGreeting());
    }
}
#+end_example

The other thing that gradle went ahead and did for us is that it made some extra tasks that we can take advantage
of:
#+BEGIN_SRC sh :results output :noweb yes
./gradlew tasks --all
#+END_SRC
*Outputs*:
#+begin_example
Downloading https://services.gradle.org/distributions/gradle-7.0.2-bin.zip
..........10%...........20%...........30%..........40%...........50%...........60%..........70%...........80%...........90%..........100%

> Task :tasks

------------------------------------------------------------
Tasks runnable from root project 'JavaProject'
------------------------------------------------------------

Application tasks
-----------------
app:run - Runs this project as a JVM application

Build tasks
-----------
app:assemble - Assembles the outputs of this project.
app:build - Assembles and tests this project.
app:buildDependents - Assembles and tests this project and all projects that depend on it.
app:buildNeeded - Assembles and tests this project and all projects it depends on.
app:classes - Assembles main classes.
app:clean - Deletes the build directory.
app:jar - Assembles a jar archive containing the main classes.
app:testClasses - Assembles test classes.

Build Setup tasks
-----------------
init - Initializes a new Gradle build.
wrapper - Generates Gradle wrapper files.

Distribution tasks
------------------
app:assembleDist - Assembles the main distributions
app:distTar - Bundles the project as a distribution.
app:distZip - Bundles the project as a distribution.
app:installDist - Installs the project as a distribution as-is.

Documentation tasks
-------------------
app:javadoc - Generates Javadoc API documentation for the main source code.

Help tasks
----------
buildEnvironment - Displays all buildscript dependencies declared in root project 'JavaProject'.
app:buildEnvironment - Displays all buildscript dependencies declared in project ':app'.
dependencies - Displays all dependencies declared in root project 'JavaProject'.
app:dependencies - Displays all dependencies declared in project ':app'.
dependencyInsight - Displays the insight into a specific dependency in root project 'JavaProject'.
app:dependencyInsight - Displays the insight into a specific dependency in project ':app'.
help - Displays a help message.
app:help - Displays a help message.
javaToolchains - Displays the detected java toolchains.
app:javaToolchains - Displays the detected java toolchains.
outgoingVariants - Displays the outgoing variants of root project 'JavaProject'.
app:outgoingVariants - Displays the outgoing variants of project ':app'.
projects - Displays the sub-projects of root project 'JavaProject'.
app:projects - Displays the sub-projects of project ':app'.
properties - Displays the properties of root project 'JavaProject'.
app:properties - Displays the properties of project ':app'.
tasks - Displays the tasks runnable from root project 'JavaProject' (some of the displayed tasks may belong to subprojects).
app:tasks - Displays the tasks runnable from project ':app'.

Verification tasks
------------------
app:check - Runs all checks.
app:test - Runs the unit tests.

Other tasks
-----------
app:compileJava - Compiles main Java source.
app:compileTestJava - Compiles test Java source.
components - Displays the components produced by root project 'JavaProject'. [deprecated]
app:components - Displays the components produced by project ':app'. [deprecated]
dependentComponents - Displays the dependent components of components in root project 'JavaProject'. [deprecated]
app:dependentComponents - Displays the dependent components of components in project ':app'. [deprecated]
model - Displays the configuration model of root project 'JavaProject'. [deprecated]
app:model - Displays the configuration model of project ':app'. [deprecated]
prepareKotlinBuildScriptModel
app:processResources - Processes main resources.
app:processTestResources - Processes test resources.
app:startScripts - Creates OS specific scripts to run the project as a JVM application.

BUILD SUCCESSFUL in 35s
1 actionable task: 1 executed
#+end_example

These tasks can be found in the [[./app/build.gradle][build.gradle]] and are being provided by the application plugin. Lets try one of the
these tasks right now:
#+BEGIN_SRC sh :results output :noweb yes
./gradlew compileJava
#+END_SRC
*Outputs*:
#+begin_example
: > Task :app:compileJava UP-TO-DATE
: 
: BUILD SUCCESSFUL in 551ms
: 1 actionable task: 1 up-to-date
#+end_example

Now if we look in the app directory:
#+BEGIN_SRC sh :results output :noweb yes
ls app/
#+END_SRC
*Outputs*:
#+begin_example
: build
: build.gradle
: src
#+end_example

We can see that gradle has compiled our java code and put it in a build directory in =app=. Now lets see what it
created for us:
#+BEGIN_SRC sh :results output :noweb yes
tree app/build/
#+END_SRC
*Outputs*:
#+begin_example
app/build/
├── classes
│   └── java
│       └── main
│           └── com
│               └── maker2413
│                   └── gradle
│                       └── App.class
├── generated
│   └── sources
│       ├── annotationProcessor
│       │   └── java
│       │       └── main
│       └── headers
│           └── java
│               └── main
└── tmp
    └── compileJava
        └── source-classes-mapping.txt

16 directories, 2 files
#+end_example

We also have a task that will clean up the build directory for us:
#+BEGIN_SRC sh :results output :noweb yes
./gradlew clean
#+END_SRC
*Outputs*:
#+begin_example
: > Task :app:clean
: 
: BUILD SUCCESSFUL in 507ms
: 1 actionable task: 1 executed
#+end_example

Lets see if it worked:
#+BEGIN_SRC sh :results output :noweb yes
ls app/
#+END_SRC
*Outputs*:
#+begin_example
: build.gradle
: src
#+end_example

Lets try one final task:
#+BEGIN_SRC sh :results output :noweb yes
./gradlew test
#+END_SRC
*Outputs*:
#+begin_example
> Task :app:compileJava
> Task :app:processResources NO-SOURCE
> Task :app:classes
> Task :app:compileTestJava
> Task :app:processTestResources NO-SOURCE
> Task :app:testClasses
> Task :app:test

BUILD SUCCESSFUL in 1s
3 actionable tasks: 3 executed
#+end_example

This will run the test we have defined in the =test= directory. It even generates a report in html format that we can
open in a browser of our choice to see the results:
#+BEGIN_SRC sh :results output :noweb yes
tree app/build/reports/
#+END_SRC
*Outputs*:
#+begin_example
app/build/reports/
└── tests
    └── test
        ├── classes
        │   └── com.maker2413.gradle.AppTest.html
        ├── css
        │   ├── base-style.css
        │   └── style.css
        ├── index.html
        ├── js
        │   └── report.js
        └── packages
            └── com.maker2413.gradle.html

6 directories, 6 files
#+end_example

Opening the index.html would display a site like this:
[[./screenshot.jpg]]

Feel free to play around with more of the tasks provided by the application plugin. Here are some other notable tasks
that we have available to us:
- ~gradle jar~ :: Will compile our code and create a jar file for us.
- ~gradle run~ :: Will compile and run our code.
- ~--rerun-tasks~ :: It is important to know that adding ~--rerun-tasks~ to any gradle command will ignore any existing artifacts and run it from scratch.
